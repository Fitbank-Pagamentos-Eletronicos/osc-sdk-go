# osc-sdk-go

Branch: Features/TR-6298 - Escrita de exemplo Signup

 ## :blue_book: DescriÃ§Ã£o do Projeto

SDK para integraÃ§Ã£o com a API da OSC.
    
## :rocket: Instalando

Para clonar o projeto e executar essa aplicaÃ§Ã£o, vocÃª precisarÃ¡ do [Git](https://git-scm.com) e do [Go](https://golang.org/) instalados em seu computador.
Depois disso execute os seguintes comandos:

```bash
    # Clone esse repositÃ³rio
    git clone https://github.com/Fitbank-Pagamentos-Eletronicos/osc-sdk-go.git
    
    # Entre no repositÃ³rio
    cd osc-sdk-go
    cd src/main
    
    # Execute o projeto
    go run main.go


```

## :file_folder: Estrutura dos diretÃ³rios

    ðŸ“¦osc-sdk-go
    â”£ ðŸ“‚bin
    â”£ ðŸ“‚Idea
    â”£ ðŸ“‚pkg
    â”£ ðŸ“‚src
    â”ƒ â”£ ðŸ“‚domains
    â”ƒ â”£ ðŸ“‚main
    â”ƒ â”£ ðŸ“‚requests
    â”ƒ â”— ðŸ“‚utils
    â”— ðŸ“‚test


##  :hammer_and_wrench: Como executar os testes


```bash
    # Entrar no diretÃ³rio de testes
    cd test
    
    # Executar todos os testes
    go test -v ./...  Executa todos os testes
    
    # Execute apenas um test
    go test -v Address_test.go


```
## :page_with_curl: MÃ©todos

Os mÃ©todos estÃ¡o disponÃ­veis na pasta `src/requests` e sÃ£o:
 
- [x] `OAuth` - CriaÃ§Ã£o do token de autenticaÃ§Ã£o para o uso em endpoints. O resultado  Ã© o `AuthSucess`.
- [x] `DocumentRequest` - Envia um documento para anÃ¡lise. O resultado Ã© o `DocumentResponse`.
- [x] `ProposalRequest` - Recolhe e valida dados necessÃ¡rios para a criaÃ§Ã£o de propostas de acordo com os tipos de produtos selecionados. O resultado Ã© o `PipelineProposal`.
- [x] `PubSub` - ObtÃ©m o ID do projeto, ID do tÃ³pico e outras coisas. O resultado Ã© o `PubSubResponse`.
- [x] `PubsubSubscribe` - Usa os dados retornados do `PubSub` e cria um ouvinte.
- [x] `SimpleSignup` - Realiza o cadastro de usuÃ¡rios(pode retornar erro caso o usuÃ¡rio jÃ¡ exista). O resultado Ã© o `SignupResponse`.
- [x] `SignupMatchRequest` - Faz a inscriÃ§Ã£o de usuÃ¡rios e retorna os produtos de crÃ©ditos com maior chance de aprovaÃ§Ã£o. O resultado Ã© o `SignupMatchResponse`. 
- [x]  `OSC` - Realiza a criaÃ§Ã£o de instancias de OSC.

## :dart: Exemplo de uso

### Signup

#### Fluxograma
```mermaid
sequenceDiagram
    participant Client
    participant SDK
    participant Auth
    participant API

    Client->>+SDK: OSC.createInstance(client_id, client_secret)
    SDK-->>-Client: instancia osc
    
    Client->>+SDK: osc.signup(signupObject)
        opt NÃ£o autorizado 
            SDK->>+Auth: auth(client_id, client_secret, scope)
            Auth-->>-SDK: access_token
        end
        SDK->>+API: signup(signupJson, access_token)
        API-->>-SDK: pipelineJson
    SDK-->>-Client: pipeline instance
```
#### CodificaÃ§Ã£o
```Go
package main

import (
    "fmt", 
    "strings"
)

type OSC struct {
  clientId  string
  clientSecret string
  authorized bool
  api  *API
  auth *Auth
}


func (osc *OSC) createInstance(clientId string, clientSecret string) *OSC {
  osc.clientId = clientId
  osc.clientSecret = clientSecret
  osc.authorized = false
  osc.api = new(API)
  osc.auth = new(Auth)
  
  return osc
}

func (osc *OSC) signup(signupObject SignupMatch) string {
  if !osc.authorized {
    osc.authorized = true
    osc.auth.auth(osc.clientId, osc.clientSecret, "signup")
  }
  signupJson := osc.api.signup(signupObject, osc.auth.accessToken)
  return signupJson
}

```
### Signup + Proposal
#### Fluxograma
```mermaid
sequenceDiagram
    participant Client
    participant SDK
    participant Auth
    participant API
    participant PubSub

    Client->>+SDK: OSC.createInstance(client_id, client_secret)
    SDK-->>-Client: instancia osc
    
    Client->>+SDK: osc.setResponseListening(listeningFunction)
        opt NÃ£o autorizado 
            SDK->>+Auth: auth(client_id, client_secret, scope)
            Auth-->>-SDK: access_token
        end
        SDK->>+API: pubsub(access_token)
        API-->>-SDK: pubsubConfig
        par Abre socket
            SDK->>PubSub: subscription(pubsubConfig)
        end
    SDK-->>-Client: pipeline instance
    
    Client->>+SDK: osc.signup(signupObject)
        opt NÃ£o autorizado 
            SDK->>+Auth: auth(client_id, client_secret, scope)
            Auth-->>-SDK: access_token
        end
        SDK->>+API: signup(signupJson, access_token)
        API-->>-SDK: pipelineJson
    SDK-->>-Client: pipeline instance
    API->>PubSub: publica(signupResponse)
    PubSub-->>SDK: subscriptionSocket(signupResponse)
    SDK-->>Client: listeningFunction(signupResponse)
    
    Client->>+SDK: osc.proposal(pipeline_id, proposalObject)
        opt NÃ£o autorizado 
            SDK->>+Auth: auth(client_id, client_secret, scope)
            Auth-->>-SDK: access_token
        end
        SDK->>+API: proposal(pipeline_id, proposalJson, access_token)
        API-->>-SDK: pipelineJson
    SDK-->>-Client: pipeline instance
    API->>PubSub: publica(proposalResponse)
    PubSub-->>SDK: subscriptionSocket(proposalResponse)
    SDK-->>Client: listeningFunction(proposalResponse)
```
#### CodificaÃ§Ã£o
```Go
package main

import (
    "fmt", 
    "strings"
    "cloud.google.com/go/pubsub"
    "google.golang.org/api/option"
)

type OSC struct {
  clientId  string
  clientSecret string
  authorized bool
  api  *API
  auth *Auth
}


func (osc *OSC) createInstance(clientId string, clientSecret string) *OSC {
  osc.clientId = clientId
  osc.clientSecret = clientSecret
  osc.authorized = false
  osc.api = new(API)
  osc.auth = new(Auth)
  
  return osc
}

func (osc *OSC) setResponseListening(listeningFunction func(response string)) {
  if !osc.authorized {
    osc.auth.auth(osc.clientId, osc.clientSecret, "pubsub")
    osc.authorized = true
  }

}
func (osc *OSC) Proposal(pipelineId string, proposalObject interface{}) {
  if !osc.authorized {
    osc.auth.auth(osc.clientId, osc.clientSecret, "pubsub")
    osc.authorized = true
  }
}

```
### PubSub

#### Fluxograma
```mermaid
sequenceDiagram
    participant Client
    participant SDK
    participant Auth
    participant API
    participant PubSub

    Client->>+SDK: OSC.createInstance(client_id, client_secret)
    SDK-->>-Client: osc instance

    Client->>+SDK: osc.setResponseListening(listeningFunction)
        opt Not Authorized
            SDK->>+Auth: auth(client_id, client_secret, scope)
            Auth-->>-SDK: access_token
        end
        SDK->>+API: pubsub(access_token)
        API-->>-SDK: pubsubConfig
        par Open socket
            SDK->>PubSub: subscription(pubsubConfig)
        end
    SDK-->>-Client: pipeline instance
```
#### CodificaÃ§Ã£o
```Go
 package main
 
 import (
    "fmt", 
    "strings"
    "cloud.google.com/go/pubsub"
    "google.golang.org/api/option"
 )

    type OSC struct {
      clientId  string
      clientSecret string
      authorized bool
      api  *API
      auth *Auth
    }
    

    func (osc *OSC) createInstance(clientId string, clientSecret string) *OSC {
      osc.clientId = clientId
      osc.clientSecret = clientSecret
      osc.authorized = false
      osc.api = new(API)
      osc.auth = new(Auth)
      
      return osc
          
    }
    
    func (osc *OSC) setResponseListening(listeningFunction func(message *pubsub.Message)) {
       if !osc.authorized {
          osc.authorized = true
          osc.auth.authorize(osc.clientId, osc.clientSecret, "pubsub")
       }
          
       pubsubConfig := osc.api.pubsub(osc.auth.accessToken)
       ctx := context.Background()
       client, err := pubsub.NewClient(ctx, pubsubConfig.ProjectId, option.WithCredentialsJSON([]byte(pubsubConfig.Credentials)))
       if err != nil {
         fmt.Println(err)
       }
       defer client.Close()
          
       sub := client.Subscription(pubsubConfig.Subscription)
       err = sub.Receive(ctx, func(ctx context.Context, msg *pubsub.Message) {
          msg.Ack()
          listeningFunction(string(msg.Data))
       })
       if err != nil {
         fmt.Println(err)
       }
    }
```
### Fluxo completo

#### Fluxograma
```mermaid
sequenceDiagram
    participant Client
    participant SDK
    participant Auth
    participant API
    participant PubSub

 

    Client->>+SDK: OSC.createInstance(client_id, client_secret)
    SDK-->>-Client: instancia osc

    Client->>+SDK: osc.setResponseListening(listeningFunction)
        opt NÃ£o autorizado 
            SDK->>+Auth: auth(client_id, client_secret, scope)
            Auth-->>-SDK: access_token
        end
        SDK->>+API: pubsub(access_token)
        API-->>-SDK: pubsubConfig
        par Abre socket
            SDK->>PubSub: subscription(pubsubConfig)
        end
    SDK-->>-Client: pipeline instance

    Client->>+SDK: osc.signup(signupObject)
        opt NÃ£o autorizado 
            SDK->>+Auth: auth(client_id, client_secret, scope)
            Auth-->>-SDK: access_token
        end
        SDK->>+API: signup(signupJson, access_token)
        API-->>-SDK: pipelineJson
    SDK-->>-Client: pipeline instance
    API->>PubSub: publica(signupResponse)
    PubSub-->>SDK: subscriptionSocket(signupResponse)
    SDK-->>Client: listeningFunction(signupResponse)

    Client->>+SDK: osc.proposal(pipeline_id, proposalObject)
        opt NÃ£o autorizado 
            SDK->>+Auth: auth(client_id, client_secret, scope)
            Auth-->>-SDK: access_token
        end
        SDK->>+API: proposal(pipeline_id, proposalJson, access_token)
        API-->>-SDK: pipelineJson
    SDK-->>-Client: pipeline instance

    API->>PubSub: publica(proposalResponse)
    PubSub-->>SDK: subscriptionSocket(proposalResponse)
    SDK-->>Client: listeningFunction(proposalResponse)

    par Continuara recevbendo atualizaÃ§Ã£o de status durante o fluxo
        API->>PubSub: publica(proposalStatusUpdateResponse)
        PubSub-->>SDK: subscriptionSocket(proposalResponse)
        SDK-->>Client: listeningFunction(proposalResponse)
    and Nesta etapa o envio de documentos esta liberado
        Client->>+SDK: osc.document(pipeline_id, documentObject)
            opt NÃ£o autorizado 
                SDK->>+Auth: auth(client_id, client_secret, scope)
                Auth-->>-SDK: access_token
            end
            SDK->>+API: proposal(pipeline_id, documentJson, access_token)
            API-->>-SDK: documentResponseJson
        SDK-->>-Client: documentResponse instance
    and Caso alguma proposta retorne que tem contratos para asinatura
        Client->>+SDK: osc.getContracts(customerServiceNumber)
            opt NÃ£o autorizado 
                SDK->>+Auth: auth(client_id, client_secret, scope)
                Auth-->>-SDK: access_token
            end
            SDK->>+API: getContracts(customerServiceNumber, access_token)
            API-->>-SDK: contractsResponseJson
        SDK-->>-Client: contractsResponse instance

        Client->>+SDK: osc.SignContracts(customerServiceNumber, contractsObject)
            opt NÃ£o autorizado 
                SDK->>+Auth: auth(client_id, client_secret, scope)
                Auth-->>-SDK: access_token
            end
            SDK->>+API: SignContracts(customerServiceNumber, contractsObject, access_token)
            API-->>-SDK: signContractsResponseJson
        SDK-->>-Client: signContractsResponse instance
    end
```
#### CodificaÃ§Ã£o
```Go
package main
 
 import (
    "fmt", 
    "strings"
    "cloud.google.com/go/pubsub"
    "google.golang.org/api/option"
 )

    type OSC struct {
      clientId  string
      clientSecret string
      authorized bool
      api  *API
      auth *Auth
    }
    
     func (osc *OSC) setResponseListening(listeningFunction func(message *pubsub.Message)) {
       if !osc.authorized {
          osc.authorized = true
          osc.auth.authorize(osc.clientId, osc.clientSecret, "pubsub")
       }
     
     func (osc *OSC) Proposal(pipelineId string, proposalObject interface{}) {
         if !osc.authorized {
            osc.auth.auth(osc.clientId, osc.clientSecret, "pubsub")
            osc.authorized = true
         }
     }
     
     func SinupMatchRequest(signupMatch *SignupMatch, auth *Auth) {
         signupMatchJson, _ := json.Marshal(signupMatch)
         signupMatchResponseJson := api.signup(signupMatchJson, auth.accessToken)
         signupMatchResponse := SignupMatchResponse{}
         json.Unmarshal(signupMatchResponseJson, &signupMatchResponse)
         return signupMatchResponse
     }

```

